// RUN: %optcall --convert-lospn-structure-to-cpu %s | FileCheck %s

module  {
  "lo_spn.kernel"() ( {
  ^bb0(%arg0: memref<?x2xi32>, %arg1: memref<?xf64>):  // no predecessors
    %c0 = constant 0 : index
    %0 = dim %arg0, %c0 : memref<?x2xi32>
    %1 = alloc(%0) : memref<?xf64>
    "lo_spn.task"(%arg0, %1) ( {
    ^bb0(%arg2: index, %arg3: memref<?x2xi32>, %arg4: memref<?xf64>):  // no predecessors
      %4 = "lo_spn.batch_read"(%arg3, %arg2) {sampleIndex = 0 : ui32} : (memref<?x2xi32>, index) -> i32
      %5 = "lo_spn.batch_read"(%arg3, %arg2) {sampleIndex = 1 : ui32} : (memref<?x2xi32>, index) -> i32
      %6 = "lo_spn.body"(%4, %5) ( {
      ^bb0(%arg5: i32, %arg6: i32):  // no predecessors
        %7 = "lo_spn.histogram"(%arg5) {bucketCount = 2 : ui32, buckets = [{lb = 0 : i32, ub = 1 : i32, val = 2.500000e-01 : f64}, {lb = 1 : i32, ub = 2 : i32, val = 7.500000e-01 : f64}], supportMarginal = false} : (i32) -> f64
        %8 = "lo_spn.histogram"(%arg6) {bucketCount = 2 : ui32, buckets = [{lb = 0 : i32, ub = 1 : i32, val = 4.500000e-01 : f64}, {lb = 1 : i32, ub = 2 : i32, val = 5.500000e-01 : f64}], supportMarginal = false} : (i32) -> f64
        %9 = "lo_spn.mul"(%7, %8) : (f64, f64) -> f64
        %18 = "lo_spn.log"(%9) : (f64) -> f64
        "lo_spn.yield"(%18) : (f64) -> ()
      }) : (i32, i32) -> f64
      "lo_spn.batch_write"(%6, %arg4, %arg2) : (f64, memref<?xf64>, index) -> ()
      "lo_spn.return"() : () -> ()
    }) {batchSize = 10 : ui32} : (memref<?x2xi32>, memref<?xf64>) -> ()
    %2 = tensor_load %1 : memref<?xf64>
    %3 = tensor_to_memref %2 : memref<?xf64>
    "lo_spn.copy"(%3, %arg1) : (memref<?xf64>, memref<?xf64>) -> ()
    "lo_spn.return"() : () -> ()
  }) {sym_name = "spn_kernel", type = (memref<?x2xi32>, memref<?xf64>) -> ()} : () -> ()
}

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py


// CHECK-LABEL:   func @task_0(
// CHECK-SAME:                 %[[VAL_0:.*]]: memref<?x2xi32>,
// CHECK-SAME:                 %[[VAL_1:.*]]: memref<?xf64>) {
// CHECK:           %[[VAL_2:.*]] = constant 0 : index
// CHECK:           %[[VAL_3:.*]] = constant 0 : index
// CHECK:           %[[VAL_4:.*]] = dim %[[VAL_0]], %[[VAL_3]] : memref<?x2xi32>
// CHECK:           %[[VAL_5:.*]] = constant 1 : index
// CHECK:           scf.for %[[VAL_6:.*]] = %[[VAL_2]] to %[[VAL_4]] step %[[VAL_5]] {
// CHECK:             %[[VAL_7:.*]] = "lo_spn.batch_read"(%[[VAL_0]], %[[VAL_6]]) {sampleIndex = 0 : ui32} : (memref<?x2xi32>, index) -> i32
// CHECK:             %[[VAL_8:.*]] = "lo_spn.batch_read"(%[[VAL_0]], %[[VAL_6]]) {sampleIndex = 1 : ui32} : (memref<?x2xi32>, index) -> i32
// CHECK:             %[[VAL_9:.*]] = "lo_spn.histogram"(%[[VAL_7]]) {bucketCount = 2 : ui32, buckets = [{lb = 0 : i32, ub = 1 : i32, val = 2.500000e-01 : f64}, {lb = 1 : i32, ub = 2 : i32, val = 7.500000e-01 : f64}], supportMarginal = false} : (i32) -> f64
// CHECK:             %[[VAL_10:.*]] = "lo_spn.histogram"(%[[VAL_8]]) {bucketCount = 2 : ui32, buckets = [{lb = 0 : i32, ub = 1 : i32, val = 4.500000e-01 : f64}, {lb = 1 : i32, ub = 2 : i32, val = 5.500000e-01 : f64}], supportMarginal = false} : (i32) -> f64
// CHECK:             %[[VAL_11:.*]] = "lo_spn.mul"(%[[VAL_9]], %[[VAL_10]]) : (f64, f64) -> f64
// CHECK:             %[[VAL_12:.*]] = "lo_spn.log"(%[[VAL_11]]) : (f64) -> f64
// CHECK:             "lo_spn.batch_write"(%[[VAL_12]], %[[VAL_1]], %[[VAL_6]]) : (f64, memref<?xf64>, index) -> ()
// CHECK:           }
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func @spn_kernel(
// CHECK-SAME:                     %[[VAL_0:.*]]: memref<?x2xi32>,
// CHECK-SAME:                     %[[VAL_1:.*]]: memref<?xf64>) {
// CHECK:           %[[VAL_2:.*]] = constant 0 : index
// CHECK:           %[[VAL_3:.*]] = dim %[[VAL_0]], %[[VAL_2]] : memref<?x2xi32>
// CHECK:           %[[VAL_4:.*]] = alloc(%[[VAL_3]]) : memref<?xf64>
// CHECK:           call @task_0(%[[VAL_0]], %[[VAL_4]]) : (memref<?x2xi32>, memref<?xf64>) -> ()
// CHECK:           %[[VAL_5:.*]] = tensor_load %[[VAL_4]] : memref<?xf64>
// CHECK:           %[[VAL_6:.*]] = tensor_to_memref %[[VAL_5]] : memref<?xf64>
// CHECK:           "lo_spn.copy"(%[[VAL_6]], %[[VAL_1]]) : (memref<?xf64>, memref<?xf64>) -> ()
// CHECK:           "lo_spn.return"() : () -> ()
// CHECK:         }
